/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Peter Nemes
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package hu.nemes.projecteuler.page1;

import java.math.BigInteger;
import java.util.concurrent.Callable;
import java.util.stream.IntStream;
import java.util.stream.LongStream;

public final class Problem029 implements Callable<Long> {

	/**
	 * Distinct powers
	 * Problem 29
	 *
	 * Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
	 *
	 *     22=4, 23=8, 24=16, 25=32
	 *     32=9, 33=27, 34=81, 35=243
	 *     42=16, 43=64, 44=256, 45=1024
	 *     52=25, 53=125, 54=625, 55=3125
	 *
	 * If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:
	 *
	 * 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
	 *
	 * How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
	 */
	@Override
	public Long call() {
		return LongStream
					.rangeClosed(2, 100)
					.parallel()
					.mapToObj(a -> BigInteger.valueOf(a))
					.flatMap(a -> IntStream
								.rangeClosed(2, 100)
								.parallel()
								.mapToObj(b -> a.pow(b))
					)
					.distinct()
					.count();
	}
}
