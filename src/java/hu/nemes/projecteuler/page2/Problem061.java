/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Peter Nemes
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package hu.nemes.projecteuler.page2;

import hu.nemes.projecteuler.common.StreamUtils;

import java.util.Arrays;
import java.util.concurrent.Callable;
import java.util.function.LongSupplier;
import java.util.function.LongUnaryOperator;
import java.util.function.Predicate;

public final class Problem061 implements Callable<Long> {

	/**
	 * Cyclical figurate numbers
	 * Problem 61
	 *
	 * Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
	 * Triangle 	  	P3,n=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
	 * Square 	  		P4,n=n2 	  		1, 4, 9, 16, 25, ...
	 * Pentagonal 	  	P5,n=n(3n−1)/2 	  	1, 5, 12, 22, 35, ...
	 * Hexagonal 	  	P6,n=n(2n−1) 	  	1, 6, 15, 28, 45, ...
	 * Heptagonal 	  	P7,n=n(5n−3)/2 	  	1, 7, 18, 34, 55, ...
	 * Octagonal 	  	P8,n=n(3n−2) 	  	1, 8, 21, 40, 65, ...
	 *
	 * The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
	 *
     * The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
     * Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
     * This is the only set of 4-digit numbers with this property.
	 *
	 * Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
	 */
	private final long[] generateNumbers(LongUnaryOperator f) {
		return StreamUtils.generate(new LongSupplier() {

			private long n = 0;

			@Override
			public long getAsLong() {
				return f.applyAsLong(++n);
			}

		}, n -> n < 10000).filter(n -> n > 1000).toArray();
	}

	@Override
	public Long call() {
		final LongUnaryOperator[] ops = new LongUnaryOperator[] {
				n -> (n * (n + 1)) / 2,
				n -> n * n,
				n -> (n * ((3 * n) - 1)) / 2,
				n -> n * ((2 * n) - 1),
				n -> (n * ((5 * n) - 3)) / 2,
				n -> n * ((3 * n) - 2)
		};

		final long[][] numbers = new long[ops.length][];
		Arrays.setAll(
				numbers,
				i -> generateNumbers(ops[i]));

		final long[] answer = Arrays
			.stream(numbers[ops.length - 1])
			.mapToObj(i -> {
				final long[] solution = new long[6];
				solution[5] = i;
			    return findNext(numbers, solution, 5, 1) ? solution : null;
			})
			.filter(Predicate.isEqual(null).negate())
			.reduce((a1, a2) -> {
				throw new AssertionError(String.format("Multiple solutions exists (%d, %d)!", a1, a2));
			})
			.get();

		return Arrays.stream(answer).sum();
	}

	public boolean findNext(long[][] numbers, long[] solution, int last, int length) {
	    for (int i = 0; i < solution.length; i++) {
	        if (solution[i] != 0) {
	        	continue;
	        }
	        for (int j = 0; j < numbers[i].length; j++) {

	        	boolean unique = true;
	            for (final long element : solution) {
	                if (numbers[i][j] == element) {
	                    unique = false;
	                    break;
	                }
	            }

	            if ( unique &&
	                 ((numbers[i][j] / 100) == (solution[last] % 100))) {

	                solution[i] = numbers[i][j];
	                if ((length == 5) && ((solution[5] / 100) == (solution[i] % 100))) {
	                    return true;
	                }
	                if (findNext(numbers, solution, i, length + 1)) {
	                	return true;
	                }
	            }
	        }
	        solution[i] = 0;
	    }
	    return false;
	}
}